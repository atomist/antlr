import { logger } from "@atomist/automation-client/internal/util/logger";
import { File } from "@atomist/automation-client/project/File";
import { FileParser } from "@atomist/automation-client/tree/ast/FileParser";
import { fillInEmptyNonTerminalValues } from "@atomist/tree-path/manipulation/enrichment";
import { TreeNode } from "@atomist/tree-path/TreeNode";
import { ANTLRInputStream, CommonTokenStream, Lexer, Parser, TokenStream } from "antlr4ts";
import { TreeBuildingListener } from "./TreeBuildingListener";

/**
 * Required functions on a lexer class generated by ANTLR
 */
export interface LexerClass {

    new(is: ANTLRInputStream): Lexer;

    // Expected but unfortunately private so can't be put on interface
    // readonly _SYMBOLIC_NAMES: (string | undefined)[];

}

/**
 * Required functions on a parser class generated by ANTLR
 */
export interface ParserClass {

    readonly ruleNames: string[];

    new(ts: TokenStream): Parser;

}

/**
 * Generic FileParser implementation based on an ANTLR grammars.
 */
export class AntlrFileParser implements FileParser {

    /**
     * Create a generic FileParser using an ANTLR grammar.
     * Use like this, passing in the lexer and parser classes:
     * const p = new AntlrFileParser("compilationUnit", JavaLexer, JavaParser);
     * @param {string} rootName name of top level production.
     * @param lexerClass lexer class
     * @param parserClass parser class
     */
    constructor(public rootName: string,
                private lexerClass: LexerClass,
                private parserClass: ParserClass) {
    }

    public toAst(f: File): Promise<TreeNode> {
        return f.getContent()
            .then(content => {
                logger.debug("Parsing file [%s] using ANTLR grammar, looking for production '%s'",
                    f.path, this.rootName);
                const inputStream = new ANTLRInputStream(content);
                const lexer = new this.lexerClass(inputStream);
                const tokenStream = new CommonTokenStream(lexer);
                const parser = new this.parserClass(tokenStream);
                const mbl = new TreeBuildingListener(
                    i => this.parserClass.ruleNames[i],
                    i => (this.lexerClass as any)._SYMBOLIC_NAMES[i]);
                parser.addParseListener(mbl);
                (parser as any)[this.rootName]();
                // logger.debug(cu.toStringTree());
                fillInEmptyNonTerminalValues(mbl.root, content);
                return mbl.root;
            });
    }
}
